# Bunch ID data buffer transmission
#
# Mandatory macros:
#  SYS = System name (ie FIN)
#  DEVICE = Device name (ie EVG0)
#  NAME = regDev name as configured with  mrfioc2_regDevConfigure() (ie EVG0DBUF)
#  
# Optional macros:
#  PULSEID_OFFSET = address offset (0x10)
#  MASTSEC_OFFSET = seconds offset (default: 0x18)
#  MASTNSEC_OFFSET = nsec offset (default: 0x1C)
#
# Description:
#
# This database transmits the bunch id via databuffer, using Tom Slejko's driver
# (regDev). It loads the bunchId integer into the appropriate register and then flushes
# the buffer.
#
record(ao, "$(SYS)-$(DEVICE):BunchIdTx-I") {
  field(DTYP, "regDev")
  field(OUT, "@$(NAME):$(PULSEID_OFFSET=0x10) T=double")
  field(FLNK, "$(SYS)-$(DEVICE):BunchIdTx-MASTER-TIMESTAMP")
}

# reads timestamp (of the master) 
# and overwrites the 16 LSB of 32-bits nsec with 16 LSB of pulse ID
# it gives seconds past epics epoch in VAL
# it gives nsec of epics timestamp in RVAL  
#
record(ai,"$(SYS)-$(DEVICE):BunchIdTx-MASTER-TIMESTAMP") {
  field(DTYP,"Soft SetTimestamp")
  field(INP,"$(SYS)-$(DEVICE):BunchIdTx-I")
  field(TSE,"-2")
  field(FLNK,"$(SYS)-$(DEVICE):BunchIdTx-MASTER-TS-SEC")
}

record(calcout,"$(SYS)-$(DEVICE):BunchIdTx-MASTER-TS-SEC") {
  field(DTYP, "regDev")
  field(INPA,"$(SYS)-$(DEVICE):BunchIdTx-MASTER-TIMESTAMP.VAL")    # master timestamp seconds
  field(CALC,"A")
  field(OUT, "@$(NAME):$(MASTSEC_OFFSET=0x18) T=UINT32")
  field(FLNK,"$(SYS)-$(DEVICE):BunchIdTx-MASTER-TS-NSEC")
}

record(calcout,"$(SYS)-$(DEVICE):BunchIdTx-MASTER-TS-NSEC") {
  field(DTYP, "regDev")
  field(INPA,"$(SYS)-$(DEVICE):BunchIdTx-MASTER-TIMESTAMP.RVAL")   # master timestamp nanoseconds
  field(CALC,"A")
  field(OUT, "@$(NAME):$(MASTNSEC_OFFSET=0x1C) T=UINT32")
  field(FLNK, "$(SYS)-$(DEVICE):BunchIdTx-Flush_")
}

record(longout, "$(SYS)-$(DEVICE):BunchIdTx-Flush_") {
  field(DTYP, "regDev")
  field(OUT, "@$(NAME):0x0")
  field(VAL, "1")
  field(FLNK,"$(SYS)-$(DEVICE):BunchIdTx-PERF-CURR_")
}

record(calcout, "$(SYS)-$(DEVICE):BunchIdTx_") {
  field(CALC, "A")
  field(INPA, "$(SYS)-$(DEVICE):BunchIdTx-PulseCounter")
  field(OUT, "$(SYS)-$(DEVICE):BunchIdTx-I PP")
  field(FLNK, "$(SYS)-$(DEVICE):BunchIdTx-jump-counter")
}

record(calcout,"$(SYS)-$(DEVICE):BunchIdTx-jump-counter") {         
  field(INPA,"$(SYS)-$(DEVICE):BunchIdTx_")
  field(INPB,"$(SYS)-$(DEVICE):BunchIdTx-jump-counter")
  field(INPC,"$(SYS)-$(DEVICE):BunchIdTx-jump-counter.OVAL")
  field(CALC,"A")
  field(OCAL,"A-B#1?C+1:C")
  field(OOPT,"When Non-zero")
  field(DOPT,"Use OCAL")
}

#### measures time interval between pulse ID arraivals ###
record(ai,"$(SYS)-$(DEVICE):BunchIdTx-PERF-CURR_") {
  field(DTYP,"Soft Timestamp")
  field(PREC,"9")
  field(PRIO,"HIGH")
  field(FLNK,"$(SYS)-$(DEVICE):BunchIdTx-PERF-I")
}

##Time from previous in us
record(calc,"$(SYS)-$(DEVICE):BunchIdTx-PERF-I"){
  field(INPA,"$(SYS)-$(DEVICE):BunchIdTx-PERF-CURR_ NPP")
  field(INPB,"$(SYS)-$(DEVICE):BunchIdTx-PERF-PERF_PREV_ NPP")
  field(CALC,"(A-B)*1000")
  field(PREC,"9")
  field(FLNK,"$(SYS)-$(DEVICE):BunchIdTx-PERF-PERF_PREV_")
}

record(ai, "$(SYS)-$(DEVICE):BunchIdTx-PERF-PERF_PREV_"){
  field(DESC,"Performance meas previous time")
  field(INP, "$(SYS)-$(DEVICE):BunchIdTx-PERF-CURR_ NPP")
  field(PREC,"9" )
  field(FLNK,"$(SYS)-$(DEVICE):BunchIdTx-PERF-MAX-I")
}


record(calc,"$(SYS)-$(DEVICE):BunchIdTx-PERF-MAX-I"){
  field(INPA,"$(SYS)-$(DEVICE):BunchIdTx-PERF-I NPP")
  field(INPB,"$(SYS)-$(DEVICE):BunchIdTx-PERF-MAX-I NPP")
  field(CALC,"ABS(10-A) > B ? ABS(10-A) : B")
  field(PREC,"9")
  field(EGU, "ms")
}